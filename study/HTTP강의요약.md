# HTTP 강의 요약

# IP 프로토콜

- 노드(서버)를 통해서 메세지+출발주소+도착주소를 보냄

### 한계점

- 연결불능 상태여도 메세지가 보내짐.
- 순서가 부정확함
- 여러가지 애플리케이션에서 받는 패킷을 구분하기 어려움

### => TCP 프로토콜의 탄생

# TCP

전송 제어 프로토콜

### 특징

- 연결지향 (3 way handshake)
- 데이터 전달 보증
- 순서 보장

### TCP 패킷 순서

- 메세지
- TCP헤더 (출발지 PORT, 목적지 PORT, 전송제어, 순서, 검증 정보)
- IP헤더 (출발지 IP, 목적지 IP, 등등..)
- Ethernet frame (MAC과 같은 물리적 주소)

### 3 WAY HANDSHAKE

1. 클라이언트 → SYN → 서버
2. 서버 → SYN, ACK → 클라이언트
3. 클라이언트 → ACK → 서버

# UDP

- 기능이 별로 없음
- 연결 지향 X
- 데이터 전달 보증X
- 순서 보장 X
- 하지만 단순하고 빠름
- IP와 거의 같음 PORT + 체크섬 정도만 추가
- 애플리케이션에서 추가 작업 해야함

## PORT

한 IP에서 프로세스별로 포트를 나누어서 패킷 통신을 할 수 있도록 함

## DNS

IP를 도메인에 연결해주는 서비스

IP는 변하기 쉽고 기억하기 어려움

# URI

URN + URL + etc. = URI

URN은 리소스에 이름을 부여하는 방법(거의 사용되지 않음)

### URL 문법

예시 = https://www.google.com:443/search?q=hello&hl=ko

- 프로토콜(https) 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙
- (userinfo@) 거의 사용하지 않음 - 사용자 정보
- 호스트 명(www.google.com)
- 포트(443) 생략 가능
- 리소스 경로(search) 계층적 구조, 설계하기 나름임
- 쿼리(?q=hello&hl=ko) key = value 형태
?로 시작 &로 추가 가능
query parameter, query string등으로 불림
- fragment(#~~) html 내부 정보로 제공됨. 특정 위치로 이동하거나 등등

# 웹 브라우저

### 브라우저에서 패킷 보내는 순서

- 웹 브라우저에서 HTTP 메시지 생성(메서드, 타입, 길이, HTML 등)
- SOCKET 라이브러리를 통해서 TCP 계층에 전달
- 이후 TCP 통신

# HTTP

기존의 HTTP는 HTML을 전송하는 목적

최근에는 이미지, 영상, JSON 거의 대부분의 데이터를 HTTP로 보냄

HTTP 1.1에 지금 대부분의 기능이 포함되어있음.

# Stateful, Stateless

- **Stateful** : 상태유지 (주고 받는 정보를 서버가 가지고 있음)

    서버를 증설하기 힘들다. 왜냐하면 상태를 유지하고 있기 때문에 하나의 클라이언트가 하나의 서버와만 통신해야 하기 때문에.

- **Stateless** : 무상태 (보내는 모든 정보를 클라이언트가 계속 보내줌)

    서버를 증설할 수 있음. 

상태 유지는 **최소화**하여 설계하여야 한다. 

트래픽이 많아지면 서버 증설하기 쉽게 설계하는 방법임.

### 동시에 발생하는 대용량 트래픽

보통 버튼을 누르기 전에 잠깐 시선을 돌릴 수 있는 HTML파일을 배치하고 조금이나마 분산시키는 방법

# HTTP 메시지

모든 것을 전송할 수 있다.

### 요청 메시지

시작 라인 : 메서드, 파라미터, HTTP 버전 등

헤더 : 호스트의 주소 (도메인)

공백라인 : 아무것도 들어가지 않는 공백 (엔터 한 방)

바디 : 있다면 포함 가능

### 응답 메시지

시작 라인 : HTTP버전, HTTP코드(200, 404 등)

헤더 : Context-Type, 길이 등(Body에 대한 설명)

공백 라인

바디 : HTML 문서

# HTTP API

API를 설계할 때 가장 중요한 것은 **리소스 식별**

안좋은 예시                |  좋은 예시
:-------------------------:|:-------------------------:
![api.png](uploads/25b9d445f6d991a3f0a429cc44b789d9/api.png.jpg)  |  ![api](uploads/954f5cc4e151efc9429e6d5b0a2e58a5/api.jpg)



URI는 리소스만 식별해야한다.

리소스와 해당 리소스를 대상으로 하는 행위를 분리

리소스는 명사 / 행위는 동사

HTTP 메서드를 통해서 행위를 구분

### GET

리소스 조회

서버에 전달하고 싶은 데이터는 Query(쿼리 파라미터, 쿼리 스트링)를 통해서 전달

메세지 바디를 사용해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아서 권장하지 않음.

**캐싱을 할 수 있다**

### POST

요청 데이터 처리

메시지 바디를 통해 서버로 요청 데이터 전달

서버는 요청 데이터를 **처리**

- 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행한다.

주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용

### PUT

리소스를 대체

- 리소스가 있으면 대체
- 리소스가 없으면 생성
- 덮어쓰기와 비슷함

**클라이언트가 리소스를 식별함**

- 클라이언트가 리소스 위치를 알고 URI 지정
- POST와 차이점

**주의**

리소스를 완전히 대체한다.

리소스에 부분적으로 수정하지 못하고 전체를 없애고 부분만 저장함.

### PATCH

리소스를 부분적으로 수정하고 싶다면 쓸 수 있는 메서드

### DELETE

리소스 제거

리소스 위치만 담아서 보내면 삭제함

## 안전

호출해도 리소스를 변경하지 않는다.

## 멱등

한 번 호출하든, 여러번 호출하든 결과가 똑같다.

**get, put, delete** : 멱등하다

**post** : 멱등하지 않음.

## 캐시가능

GET, HEAD, POST, DELETE 캐시가능

- 실제로는 GET, HEAD 정도만 캐시로 사용
- POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는데, 구현이 쉽지 않음.

# API 설계

### 파일 관리 시스템 예시

- 파일 목록 /files → **GET**
- 파일 조회 /files/{filename} → **GET**
- 파일 등록 /files/{filename} → **PUT**
- 파일 삭제 /files/{filename} → **DELETE**
- 파일 대량 등록 /files → **POST**

### 신규 파일 등록 시 POST와 PUT의 차이

**POST** 

- 클라이언트가 리소스의 주소를 모른다
- 서버에서 리소스의 주소를 생성하고 알려줌
- 컬렉션(Collection) 이라고 함

**PUT**

- 클라이언트가 리소스의 URI를 알고 있어야 함
- 클라이언트가 직접 리소스의 URI를 지정함
- 스토어(Store)라고 한다.

### HTML FORM을 사용할 때

GET, POST밖에 사용할 수 없음.

따라서 DELETE와 같은 작업을 처리할 때는 

/members/{id}/**delete → POST**

에서 /delete 와 같은 컨트롤 URI를 사용할 수 있음.

하지만 컨트롤 URI는 너무 막 쓰면 안좋다.

HTTP 메서드로 해결하기 애매한 경우 사용할 수 있음.

**동사**를 사용해야한다. → /delete, /edit 등등

## 정리 - 참고하면 좋은 URI 설계 개념

### 문서

- 단일 개념 - 예) /members/100, /files/star.jpg

### 컬렉션

- 서버가 관리하는 리소스 디렉토리
- 서버가 리소스의 URI를 생성하고 관리
- 예) /members

### 스토어

- 클라이언트가 관리하는 리소스 디렉토리
- 클라이언트가 리소스의 URI를 알고 관리함.
- 예) /files

### 컨트롤러, 컨트롤 URI

- 문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행.
- 동사를 직접 사용
- 예) /members/{id}/delete

# HTTP 상태 코드

**1xx** : 요청이 수신되어 처리중 (거의 사용되지 않음)

**2xx**: 요청 정상 처리

**3xx** : 요청을 완료하려면 추가 행동이 필요.

**4xx** : 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음.

**5xx** : 서버 오류, 서버가 정상 요청을 처리하지 못함.

# 리다이렉션 - 3XX

요청 보낸 URI가 없을 경우 다른 URI로 연결해줌.

- 영구 리다이렉션
- 일시적인  리다이렉션

### PRG : Post/Redirect/Get

- POST로 주문 후에 새로고침으로 인한 중복 주문 방지
- POST로 주문 후에 주문 결과 화면을 GET 메서드로 리다이렉트
- 새로고침해도 결과 화면을 GET으로 조회
- 중복 주문 대신에 결과 화면만 GET으로 다시 요청

**응답으로 200을 주는게 아니고 302나 303으로 되돌려줌**

결과 : 주문 후 새로고침을 해도 POST가 아니고 GET으로 리다이렉트 되기 때문에 결과 화면만 조회됨.

- 302 : Found → GET으로 변할 수 있음(May)
- 307 : Temporary Redirect → 메서드가 변하면 안됨
- 303 : See Other → 메서드가 GET으로 변경

## 전송 방식

- 단순 전송
- 압축 전송
- 분할 전송 - 용량이 큰 데이터를 쪼개서 받는 데로 표시하는 방식

## 일반 정보

- FROM - 유저의 이메일 정보
- Referer - 현재 요청된 페이지의 이전 웹 페이지 주소 (유입 경로 분석)
- User-agent - 웹 브라우저 정보 (클라이언트 애플리케이션 정보)
- Server - 요청을 처리하는 ORIGIN 서버의 소프트웨어 정보

## 특별한 정보

- Host - 요청한 호스트 정보
- Location - 페이지 리다이렉션
- Allow - 허용 가능한 HTTP 메서드
- Retry-After - 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간

## 인증 헤더

- Authorization - 클라이언트 인증 정보를 서버에 전달
- WWW-Authenticate - 리소스 접근시 필요한 인증 방법 정의

# 쿠키

- Set-Cookie - 서버에서 클라이언트로 쿠키 전달
- Cookie - 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청시 서버로 전달

HTTP는 무상태(Stateless) 프로토콜이기 때문에 요청을 보내고 나면 연결이 끝남

네트워크 트래픽이 추가로 유발되기 때문에 최소한의 정보만 사용해야 함.

### 작동 방식

1. 클라이언트(브라우저)가 서버에 로그인 요청을 보냄
2. 서버가 Set-Cookie에 유저 정보를 감싸서 클라이언트로 보냄
3. 브라우저가 Cookie 저장소에 이 쿠키를 저장함
4. 다음번 요청을 보낼 때 이 쿠키를 함께 보냄
5. 서버는 로그인 된 유저를 인식할 수 있음.

## 검증 헤더

- Last-Modify

마지막에 수정된 날짜, 시간을 확인해서 캐시된 데이터의 유효성을 검증

- ETag

데이터에 tag를 붙여서 서버에 보내서 같으면 유지하고 다르면 다시 받기

캐시 제어 로직을 서버에서 완전히 관리.

클라이언트는 캐시의 메커니즘에 대해 알 수 없게 됨.

## 캐시

캐시를 사용해서 불필요한 리소스 전송을 최소화할 수 있다.

### 프록시 캐시

![Untitled](uploads/6cbbb7821ab9b6de8c361f1d1b16c0c0/Untitled.png)

미국에 있는 원(origin) 서버에서 다운받으면 물리적인 거리가 멀기 때문에 속도가 많이 느리다.

클라이언트와 가까운 위치에 프록시 캐시 서버를 위치시켜서 원 서버의 리소스를 미리 다운로드 받아놓고 클라이언트에게 빠른 속도로 제공해준다.

## Cache-Control

캐시 지시어 - 캐시 무효화 

- **no-cache** : 캐시해도 되지만 원 서버에 검증하고 사용
- **no-store** : 민감한 정보가 있으므로 절대 저장하면 안됨
- **must-revalidate** : 캐시 만료후 최초 조회시 원 서버에 검증
- **Pragma** - no-cache : http 1.0 이하 하위호환용