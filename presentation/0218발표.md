 ## :memo: 6주차 작업 목록
- 개발 진행 사항
- 차주 개발 목표
- 질의 사항

## :date: 개발 진행 사항  

### JPA 상속 관계 매핑을 통한 엔티티 수정   
- **첫 의도**는 게시판들이 공통적인 데이터와 기능이 있었기에   
  부모 클래스로 공통적인 정보를 상속 받아 **코드 재사용을 목적**으로 상속을 표현하고자 함.

- JPA를 활용할 때 엔티티 객체 사이에 어떠한 방법으로 상속을 표현할 수 있는지 알아본 결과   
  지난 주차까지 기본 엔티티 설계와 ERD 설계가 진행됐던 것을 토대로하면   
  **@MappedSuperclass** 라는 어노테이션을 활용해서 엔티티에서 **공통으로 사용할 정보들을 매핑**할 수 있음을 파악.

    1. 부모 클래스   
![엔티티_수정1](/uploads/0562c15aaab2f9d413205e58f8ef5f7a/엔티티_수정1.PNG)
    2. 자식 클래스   
![엔티티_수정2](/uploads/e86d52bd0779ae4b5ee3a79bb7956f1b/엔티티_수정2.PNG)
    3. 패키지 구조 변경   
![구조변경](/uploads/841004fa3f050ad848c1621146730af1/구조변경.PNG)
  
### JPA 상속 관계 매핑에 대한 학습 내용   
- 관계형 데이터 베이스는 상속을 지원하지 않으나, 슈퍼타입-서브타입 관계라는 모델링 기법이 객체 상속과 유사한 모습을 보이고 있음.  
- 따라서 상속 관계 매핑이란, 객체의 상속구조와 DB의 슈퍼타입-서브타입 관계를 매핑하는 것으로 표현
- 이러한 상속 관계 매핑에 대해 JPA가 제공해주는 전략들이 있다
- 전략에 따라 전체적인 소스 코드는 큰 차이가 없지만 **DB 테이블의 구조가 다르다**   

     + 조인 전략
![조인전략](/uploads/bf27f7bab95fbd49b191dc17bd6ac0e1/조인전략.png)   
          1. 각각 슈퍼타입, 서브타입 각각의 테이블을 **모두 생성**하는 전략이다   
          2. @Inheritance(strategy = **InheritanceType.JOINED**) 어노테이션을 활용하여 Join방식으로 상속을 매핑하겠다 표현   
          3. @DiscriminatorColoumn(name="DTYPE") : 하위 타입을 구별할 수 있는 DTYPE 컬럼을 슈퍼타입에 추가한다
          4. @DiscriminatorValue("XXX") : DTYPE 컬럼에 표기되는 하위타입의 이름을 지정할 수 있다 (기본 값은 엔티티 명)    
          - 장점
              + 테이블 정규화
              + 외래키 참조 무결성 제약조건 활용가능
              + 저장공간 효율화
          - 단점
              + 조회 시 조인을 많이 사용, 성능 저하
              + 조회 쿼리가 복잡함
              + 데이터 저장시 INSERT SQL 2번 호출(슈퍼타입, 서브타입 각각)    
   

     + 단일 테이블 전략   
![단일_테이블_전략](/uploads/9d6d768c325dd6a33bd6c08209bdc3d7/단일_테이블_전략.png)   
          1. 통합 테이블을 사용하여 슈퍼타입 테이블이 서브타입 테이블의 필드를 모두 갖고 있는다   
          1. 서브 타입에 해당하는 데이터들이 많지 않을 때는 싱글 테이블 전략을 사용한다 (단순하고, 빠르다)   
          1. @Inheritance(strategy = **InheritanceType.SINGLE_TABLE**) 어노테이션으로 표현   
          1. @DiscriminatorColoumn(name="DTYPE") 조인 전략과 동일   
          1. @DiscriminatorValue("XXX") 조인 전략과 동일   
          

          - 장점
              + 조인이 필요 없으므로 일반적으로 조회 성능이 빠름
              + 조회 쿼리가 단순함
          - 단점
              + 자식 엔티티가 매핑한 컬럼은 모두 null 허용
              + 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다
              + 자식 엔티티의 컬럼이 많은 경우 조회 성능이 오히려 느려질 수 있다
   
     + 구현 클래스마다 테이블 전략   
![테이블_퍼_클래스](/uploads/53ec2b13974a2dce76f54080e3b0ee74/테이블_퍼_클래스.png)   
          1. 모든 서브타입 테이블만 생성   
          1. @Inheritance(strategy = **InheritanceType.TABLE_PER_CLASS**) 어노테이션으로 표현   
          1. 이 전략은 데이터베이스 설계자와 ORM 전문가 둘 다 **추천하지 않는 방식**이다   
          - 장점   
              + 서브 타입을 명확하게 구분해서 처리할 때 효과적   
              + not null 제약조건 사용 가능   
          - 단점   
              + **여러 자식 테이블을 함께 조회할 때** 성능이 느림(UNION SQL 필요)   
              + **단일 테이블에 모든 것을 저장**하므로 테이블이 커질 수 있다.   
     + @MappedSuperclass
          1. 보통 createdBy, createdAt, modifiedBy, modifiedAt 과 같이 전체 엔티티에서 공통으로 사용할 정보들을 매핑할 때 사용
          1. 객체 설계 시 중복을 추출할 수 있어서 유용하다
          1. (상위 클래스에 @MappedSuperclass 어노테이션 지정)
          1. 상위 클래스는 **추상 클래스로서 테이블이 생성되지 않고** 상속받은 속성들은 각각의 테이블에 자동으로 추가된다. 
          1. 조회, 검색 불가하다. (em.find(BaseEntity) 불가)

- - -
- @MappedSuperclass는 일반적인 상속의 관계(is a kind of)에서 쓰이는 것이 아닌     
  그저 **코드 중복 추출**에 초점이 맞춰진 것을 느낀 후   

   현재 설계된 구조로는 **객체지향적 프로그래밍**을 하기에 **적합하지 않다고 판단**하게 됨.   
   이에 따라, 다시 처음으로 프로젝트 요구 사항과 도메인 설계를 진행하고자 함.    

  - 단기 목표 설정
   1. 객체지향적 프로그래밍을 어떻게 할 것인가에 대해서도 정리하고 좀 더 구체적으로 방향성을 잡아라
   2. JPA를 활용하기 전에 JPA에 대한 기본 개념이 너무 부족하여 **JPA에 대한 기본 개념부터 정리**
- - -

### 객체지향 프로그래밍에 대한 학습과 방향성   
- 객체지향은 프로그램을 개발하는데 관점을 데이터와 처리 방법(메소드)로 보는 것이 아니라   
  프로그램을 수많은 '객체(object)'라는 기본 단위로 나누고 이들의 상호작용으로 서술하는 방식이다.
- 객체란 하나의 역할을 수행하는 '메소드와 변수(데이터)'의 묶음으로 봐야 한다.
   + 여기까지는 java를 활용하여 클래스를 설계하다보면 당연시하게 느낄 수 있었다
   + 그러나 객체지향 프로그래밍의 특징을 설명하기에는 이것만으로 부족하다

- 객체지향 프로그래밍의 대표적인 특징
    1. **캡슐화**   
        + 캡슐화란 위에서 표현한 '메소드와 변수(데이터)'의 묶음. 즉, 클래스 단위로 묶는 것을 캡슐화라고 표현한다.    
        + 캡슐화에서 파생된 개념으로 정보 은닉이라는 특징이 있고,   
          정보은닉은 클래스를 설계할 때 public, private, protected 등을 선언해    
          해당 정보에 접근 제한을 주는 것이다.   

    2. **상속**   
        + 상속은 자식 클래스가 부모 클래스의 특성과 기능을 그대로 물려받는 것을 말한다.
        + 기능의 일부분을 변경해야 할 경우 자식 클래스에서 상속받은 그 기능만을 수정해서   
          다시 정의하게 되는데, 이러한 작업을 '오버라이딩(Overriding)'이라고 한다.
        + 상속은 캡슐화를 유지하면서도 클래스의 재사용이 용이하도록 해 준다.


    3. **다형성**   
        + 다형성이란 하나의 변수, 또는 함수가 상황에 따라 다른 의미로 해석될 수 있는 것을 말한다.
        + 현재 활용 언어가 **JAVA이므로 자바에 관련된 다형성만 정리**한다.
            - 서브타입 다형성(Subtype Polymorphism / Inclusion Polymorphism / Subtyping)
            - 매개변수 다형성(Parametric Polymorphism)
                + 제네릭(Generic): 지정한 타입 매개변수에 해당하는 타입만을 사용하겠다고 약속하는 방식이다.
        + 임시 다형성(Ad hoc Polymorphism)
            -  함수 오버로딩(Function overloading)
            -  함수 오버로딩을 통해 동일한 이름의 함수를 매개변수에 따라 다른 기능으로 동작하도록 할 수 있다.     
               함수 오버로딩을 너무 많이 사용하면 전체적인 코드의 유지보수가 어려워지므로, 제네릭으로 대체하는 것이 일반적이다.
        + 강제 다형성(Coercion Polymorphism)
            - 묵시적 형 변환(Implicit type coercion)
            - 명시적 형 변환(Explicit type coercion)


### JPA에 대한 기초 학습 정리 과정
https://pablo-k.tistory.com/14?category=838454

### 프로젝트 요구 사항과 도메인 설계 수정 과정
https://pablo-k.tistory.com/16

### 공지사항 API 개발

![DTO설명](/uploads/0168f5cbc6729cc29a1f684791ff91a5/DTO설명.png)


1. 기존 Entity로 데이터를 주고 받는 형태였으나, 요청과 응답에 맞는 Dto를 생성하고 연동하였음.
2. 객체 매핑에 Mapstruct 사용하였음.
3. Mock 객체를 이용하여 Controller, Service에 대한 간단한 단위 테스트


![noticeTest](/uploads/a9e8844b5ad53a20baa5ba970049c95a/noticeTest.png)

### API 테스트

![notice1](/uploads/3c01dc19ed625fb317e1e9112a3b8b5a/notice1.png)

![notice2](/uploads/8e3b5b424c0ac9a1b3b41a8446f40f3c/notice2.png)

![notice4](/uploads/442a5bd9f3bafb310eb100d7971fe769/notice4.png)

![notice5](/uploads/4a1cff6ad46ea429f2c6744870521e6e/notice5.png)

![notice6](/uploads/bafa28b870f8e72447b6396e21e3dd3c/notice6.png)


## :raising_hand: 차주 개발 목표

- Pablo 개발 브랜치 머지 및 추가작업
- shared 게시판 API 개발
  - 단위테스트 선 개발, TDD 적용


---
@gm1702846 @GM1802883 @gm1902894

@gm2202969 @gm2202971 @gm2202970 @gm2202978 
